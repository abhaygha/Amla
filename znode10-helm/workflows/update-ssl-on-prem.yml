name: Update SSL Certificate Across All Environments

on:
  workflow_dispatch:
    inputs:
      tenant:
        description: 'Tenant to update (e.g., z10, etna)'
        required: true
        default: 'z10' # Default to all environments
      environments:
        description: 'Environments to update (comma-separated, e.g., dev-aks,prod-aks)'
        required: true
        default: 'all' # Default to all environments
      namespace:
        description: 'The Kubernetes namespace'
        required: true
      new_domain:
        description: 'The new domain name (e.g., znodecorp.com)'
        required: true
        default: 'znodecorp.com'
jobs:
  update-all-environments:
    # Use the static runner labels for the self-hosted runner
    runs-on: [ self-hosted, 100.195 ]

    # Define a matrix to loop through all your environments
    strategy:
      matrix:
        environment: ${{ github.event.inputs.environments == 'all' && fromJSON('["dev1", "dev2", "dev3", "dev4", "dev5", "dev6", "dev7", "dev8", "dev9", "int", "qa"]') || fromJson(format('["{0}"]', replace(github.event.inputs.environments, ',', '","'))) }}

    steps:
    - name: Checkout Template Repository
      uses: actions/checkout@v2
      with:
        repository: MRRSoft/znode10-devops-templates
        token: ${{ secrets.ACCESS_REPO }}
        ref: master

    - name: Install and Authenticate GitHub CLI
      run: |
        # This command installs the GitHub CLI on a Debian/Ubuntu-based system.
        # Change this command if your self-hosted runner uses a different OS.
        sudo apt-get update && sudo apt-get install -y gh
        echo ${{ secrets.ACCESS_REPO }} | gh auth login --with-token

    - name: Update GitHub Environment Variables
      env:
        REPO: ${{ github.repository }}
        NEW_DOMAIN: ${{ github.event.inputs.new_domain }}
      run: |
        # Split the environments input into an array
        ENVIRONMENTS=${{ github.event.inputs.environments }}
        if [[ "$ENVIRONMENTS" == "all" ]]; then
          # If "all", use a pre-defined list of all environments
          ENVIRONMENTS_TO_UPDATE=("dev1" "dev2" "dev3" "dev4" "dev5" "dev6" "dev7" "dev8" "dev9" "int" "qa")
        else
          # Otherwise, use the comma-separated input
          IFS=',' read -ra ENVIRONMENTS_TO_UPDATE <<< "$ENVIRONMENTS"
        fi

        for ENV_NAME in "${ENVIRONMENTS_TO_UPDATE[@]}"; do
          echo "Updating variables for environment: $ENV_NAME"
          
          gh variable set DOMAIN --env "$ENV_NAME" --body "$NEW_DOMAIN" --repo "$REPO"
          gh variable set URL --env "$ENV_NAME" --body "-${{ inputs.tenant }}-${ENV_NAME}.${NEW_DOMAIN}" --repo "$REPO"
          gh variable set WEBSTORE_URL --env "$ENV_NAME" --body "webstore-${{ inputs.tenant }}-${ENV_NAME}.${NEW_DOMAIN}" --repo "$REPO"
        done

    - name: Set Kubernetes Context
      uses: azure/k8s-set-context@v1
      with:
        kubeconfig: ${{ secrets[format('KUBECONFIG_{0}', matrix.environment)] }}
        version: '1.19.9'

    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: v3.13.2

    - name: Create Required Secrets
      # The vars.DOMAIN will now be the updated value from the previous step
      working-directory: ./helm-aks/znode10-helm/ssl/${{ vars.DOMAIN }}
      run: |
        echo "Deleting old TLS secret 'api-tls-secret'..."
        kubectl delete secret api-tls-secret --namespace ${{ github.event.inputs.namespace}} --ignore-not-found

        echo "Creating new TLS secret 'api-tls-secret'..."
        kubectl create secret tls api-tls-secret \
          --cert=${{ vars.DOMAIN }}.crt \
          --key=${{ vars.DOMAIN }}.key \
          --namespace ${{ github.event.inputs.namespace}}

    - name: Checkout Teams Repo with Submodules
      uses: actions/checkout@v4
      with:
        ref: master
        submodules: recursive
        token: ${{ secrets.ACCESS_REPO }}

    - name: Update submodule to latest master
      run: git submodule update --remote --checkout --recursive

    - name: Helm install znode10 chart
      working-directory: ./znode10-helm/znode-templates/helm-aks/znode10-helm
      run: |
        echo "Deploying to environment: ${{ inputs.tenant }}${{ inputs.environment }}"
        echo '${{ vars.IMAGE_TAGS }}' > image_tags.json
        set_args=""
        for service in $(jq -r 'keys[]' image_tags.json); do
          tag=$(jq -r --arg svc "$service" '.[$svc]' image_tags.json)
          if [[ -n "$tag" && "$tag" != "null" ]]; then
            echo "✅ Using provided tag for $service: $tag"
          else
            current_image=$(kubectl get deployment $service -n ${{ inputs.namespace }} -o jsonpath='{.spec.template.spec.containers[0].image}' || true)
            if [[ -n "$current_image" ]]; then
              current_tag=$(echo "$current_image" | awk -F':' '{print $2}')
              tag="$current_tag"
            else
              echo "❌ ERROR: Deployment for $service not found. Cannot continue."
              exit 1
            fi
          fi
          set_args="$set_args --set-string resources.$service.image.tag=$tag"
        done

        helm upgrade --install znode10x . \
          --namespace ${{ inputs.namespace }} \
          -f default-values.yml \
          -f internal-values.yml \
          -f ../../../../znode10-helm/${{ inputs.environment }}-values.yml \
          -f ingress-values.yml \
          -f ${{ vars.CATEGORY }}-values.yml \
          --set global.tenant=${{ inputs.tenant }} \
          --set global.environment=${{ inputs.environment }} \
          --set global.domain=${{ vars.URL }} \
          --set global.webstoreURL=${{ vars.WEBSTORE_URL }} \
          --set global.imageRegistry=${{ vars.ACR_SERVER }} \
          --set global.imagePullSecrets=${{ vars.BLACKBOX }} \
          --set global.tenantacr.imageRegistry=${{ vars.TENANT_ACR_SERVER }} \
          --set global.ingressClassName=nginx \
          --set-string global.db.wbst_db='${{ secrets.DB_WBST }}' \
          --set-string global.db.pymt_db='${{ secrets.DB_PYMT }}' \
          --set-string global.db.hgfr_db='${{ secrets.DB_HGFR }}' \
          --set-string global.db.rceg_db='${{ secrets.DB_RCEG }}' \
          --set-string storage.name="${{ secrets.STORAGE_NAME }}" \
          --set-string storage.url="https://${{ secrets.STORAGE_NAME }}.blob.core.windows.net" \
          --set-string storage.connection_string="${{ secrets.STORAGE_CONN }}" \
          --set-string global.newrelic.licensekey="${{ secrets.NEWRELIC_KEY }}" \
          --set-string global.key.domainkey="${{ vars.DOMAIN_KEY }}" \
          $set_args
    # - name: Apply ingress and restart
    #   run: |
    #     echo "Waiting 90 seconds to ensure ingress controller is ready..."
    #     sleep 90
    #     kubectl rollout restart daemonset nginx-ingress-nginx-controller -n ${{ github.event.inputs.namespace}}
