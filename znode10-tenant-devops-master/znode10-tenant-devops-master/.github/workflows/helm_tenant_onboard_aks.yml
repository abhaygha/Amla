name: Znode10 AKS Tenant Onboarding Using Helm Chart

on:
  workflow_dispatch:
    inputs:
      tenant:
        description: 'Client/Tenant Name'
        required: true
      environment:
        description: 'Environment Type'
        required: true
        default: 'np'
      subscription:
        description: 'Select azure subscription'
        required: true
        type: choice
        options:
          - AZURE_CREDENTIALS_PROD_ADMIN
          - AZURE_CREDENTIALS_NP_ADMIN
          - AZURE_CREDENTIALS_NP
      ingressip:
        description: 'Static Ingress IP'
        required: true
      domain:
        description: 'Domain name'
        required: true
        default: znodecorp.com
      cluster_type:
        description: 'Cluster Type'
        required: true
        type: choice
        options:
          - aks
          - local
      category:
        description: 'Environment Category'
        required: true
        type: choice
        options:
          - smallnonprod
          - mediumnonprod
          - largenonprod
          - smallprod
          - mediumprod
          - largeprod
      sql_admin_username:
        description: 'SQL admin username'
        required: true
      sql_admin_password:
        description: 'SQL admin password'
        required: true
        type: password
      sql_vm:
        description: 'Are you using SQL VM, Enter IP'
        required: false

jobs:
  create-github-secrets:
    name: Create GitHub Environment Secrets & Variables
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.tenant }}${{ github.event.inputs.environment }}
    steps:

      - name: Install tools
        run: sudo apt update && sudo apt install -y gh jq

      - name: Authenticate gh CLI
        run: echo "${{ secrets.ACCESS_REPO }}" | gh auth login --with-token

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets[github.event.inputs.subscription] }}

#       - name: Parse Azure Credentials
#         id: parse_creds
#         run: |
#           echo "::set-output name=subscription_id::$(echo '${{ secrets[github.event.inputs.subscription] }}' | jq -r '.subscriptionId')"


      - name: Set environment secrets and variables
        run: |
          TENANT="${{ github.event.inputs.tenant }}"
          ENV="${{ github.event.inputs.environment }}"
          ENV_NAME="${TENANT}${ENV}"
          REPO="${{ github.repository }}"
          RG_NAME="rg-${TENANT}-${ENV}"
          STORAGE_NAME="str${TENANT}${ENV}"
          ACR_NAME="acr${TENANT}${ENV}"

          SQL_USER="${{ github.event.inputs.sql_admin_username }}"
          SQL_PASS="${{ github.event.inputs.sql_admin_password }}"
          SQL_VM="${{ github.event.inputs.sql_vm }}"

          if [[ -n "$SQL_VM" ]]; then
            SQL_SERVER="$SQL_VM"
            ENC="Encrypt=False;TrustServerCertificate=True"
          else
            SQL_SERVER="tcp:sql-${TENANT}-${ENV}-ep.database.windows.net"
            ENC="Encrypt=True;TrustServerCertificate=False"
          fi

          ACR_SERVER=$(az acr show -n "$ACR_NAME" --query "loginServer" -o tsv)
          ACR_PASSWORD=$(az acr credential show -n "$ACR_NAME" --query 'passwords[0].value' -o tsv)
          STORAGE_KEY=$(az storage account keys list -g "$RG_NAME" -n "$STORAGE_NAME" --query '[0].value' -o tsv)
          STORAGE_CONN="DefaultEndpointsProtocol=https;AccountName=$STORAGE_NAME;AccountKey=$STORAGE_KEY;EndpointSuffix=core.windows.net"

          echo "Getting kubeconfig from Azure..."
          az aks get-credentials --name "aks-${TENANT}-${ENV}" --resource-group "$RG_NAME" --file kubeconfig.yaml

          # Set GitHub secrets
          gh secret set STORAGE_NAME --env "$ENV_NAME" --repo "$REPO" --body "$STORAGE_NAME"
          gh secret set STORAGE_KEY --env "$ENV_NAME" --repo "$REPO" --body "$STORAGE_KEY"
          gh secret set STORAGE_CONN --env "$ENV_NAME" --repo "$REPO" --body "$STORAGE_CONN"
          gh secret set TENANT_ACRUN --env "$ENV_NAME" --repo "$REPO" --body "$ACR_SERVER"
          gh secret set TENANT_ACRPW --env "$ENV_NAME" --repo "$REPO" --body "$ACR_PASSWORD"
          gh secret set KUBECONFIG --env "$ENV_NAME" --repo "$REPO" --body "$(cat kubeconfig.yaml)"

          # Set database connection strings
          for db in WBST RCEG PYMT HGFR; do
            db_lc=$(echo "$db" | tr '[:upper:]' '[:lower:]')
            db_name="${db_lc}_${TENANT}_${ENV}"
            conn_string="Server=${SQL_SERVER};Initial Catalog=${db_name};Persist Security Info=False;User ID=${SQL_USER};Password=${SQL_PASS};MultipleActiveResultSets=False;${ENC};Connection Timeout=30;"
            gh secret set "DB_${db}" --env "$ENV_NAME" --repo "$REPO" --body "$conn_string"
          done

          # Set GitHub variables
          gh variable set ACR_SERVER --env "$ENV_NAME" --body "znode10xregistry.azurecr.io" --repo "$REPO"
          gh variable set TENANT_ACR_SERVER --env "$ENV_NAME" --body "$ACR_SERVER" --repo "$REPO"
          gh variable set BLACKBOX --env "$ENV_NAME" --body "prodacrsecret" --repo "$REPO"
          gh variable set CATEGORY --env "$ENV_NAME" --body "${{ github.event.inputs.category }}" --repo "$REPO"
          gh variable set CLUSTER_TYPE --env "$ENV_NAME" --body "${{ github.event.inputs.cluster_type }}" --repo "$REPO"
          gh variable set DOMAIN --env "$ENV_NAME" --body "${{ github.event.inputs.domain }}" --repo "$REPO"
          echo '${{ vars.SANDBOXTAGS }}' | jq . > pretty_tags.json
          PRETTY_JSON=$(cat pretty_tags.json)
          gh variable set IMAGE_TAGS --env "$ENV_NAME" --repo "$REPO" --body "$PRETTY_JSON"
          gh variable set URL --env "$ENV_NAME" --body "-${TENANT}-${ENV}.${{ github.event.inputs.domain }}" --repo "$REPO"
          gh variable set WEBSTORE_URL --env "$ENV_NAME" --body "webstore-${TENANT}-${ENV}.${{ github.event.inputs.domain }}" --repo "$REPO"

          echo "All secrets and variables set under environment: $ENV_NAME"

      - name: Show current context
        run: kubectl config current-context --kubeconfig kubeconfig.yaml

  deploy:
    name: Deploy Znode10x Helm Chart
    runs-on: ubuntu-latest
    needs: create-github-secrets
    environment: ${{ github.event.inputs.tenant }}${{ github.event.inputs.environment }}

    env:
      KUBECONFIG: ${{ github.workspace }}/kubeconfig.yaml

    steps:
      - name: Checkout Template Repository
        uses: actions/checkout@v2
        with:
          repository: MRRSoft/znode10-devops-templates
          token: ${{ secrets.ACCESS_REPO }}
          ref: master

      - name: Kubernetes Set up
        uses: azure/k8s-set-context@v1
        with:
          kubeconfig: ${{ secrets.KUBECONFIG }}
          version: '1.19.9'

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.13.2

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets[github.event.inputs.subscription] }}


      - name: Enable Blob CSI Driver on AKS
        if: ${{ vars.CLUSTER_TYPE == 'aks' }}
        run: |
          az aks update --enable-blob-driver --yes -n aks-${{ github.event.inputs.tenant }}-${{ github.event.inputs.environment }} -g rg-${{ github.event.inputs.tenant }}-${{ github.event.inputs.environment }}

      - name: Create namespace if not exists
        run: |
          ns="znode"
          if kubectl get ns "$ns" >/dev/null 2>&1; then
            echo "‚úÖ Namespace '$ns' already exists."
          else
            echo "üì¶ Creating namespace '$ns'..."
            kubectl create ns "$ns"
          fi

      - name: Add storage class for local path
        if: ${{ vars.CLUSTER_TYPE == 'local' }}
        run: |
          kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml
          kubectl patch storageclass local-path -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

      - name: Add Bitnami Helm Repository for Redis
        working-directory: ./helm-aks/znode10-helm/redis
        run: helm repo add bitnami https://charts.bitnami.com/bitnami

      - name: Install or Upgrade Redis webstore using Helm
        working-directory: ./helm-aks/znode10-helm/redis
        run: |
          helm repo update

          set_affinity=""
          if [ "${{ vars.CLUSTER_TYPE }}" = "aks" ]; then
            set_affinity="--set master.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms[0].matchExpressions[0].key=agentpool \
              --set master.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms[0].matchExpressions[0].operator=In \
              --set master.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms[0].matchExpressions[0].values[0]=znode10apl"
          fi
          helm upgrade --install rediswebstore bitnami/redis \
            --version 21.2.3 \
            -f ${{ vars.CATEGORY }}-redis-webstore.yml -n ${{ github.event.inputs.namespace}}

      - name: Install or Upgrade Redis api using Helm
        working-directory: ./helm-aks/znode10-helm/redis
        run: |
          helm repo update

          set_affinity=""
          if [ "${{ vars.CLUSTER_TYPE }}" = "aks" ]; then
            set_affinity="--set master.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms[0].matchExpressions[0].key=agentpool \
              --set master.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms[0].matchExpressions[0].operator=In \
              --set master.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms[0].matchExpressions[0].values[0]=znode10apl"
          fi
          helm upgrade --install redisapi bitnami/redis \
            --version 21.2.3 \
            -f ${{ vars.CATEGORY }}-redis-api.yml -n ${{ github.event.inputs.namespace}}

      - name: Run Redis Client Pod for Rediswebstore in Background
        working-directory: ./helm-aks/znode10-helm
        run: |
          kubectl run --namespace znode rediswebstore-client --restart='Never' \
            --image docker.io/bitnami/redis:7.2.4-debian-11-r2 --command -- sleep infinity

      - name: Run Redis Client Pod for Redisapi in Background
        working-directory: ./helm-aks/znode10-helm
        run: |
          kubectl run --namespace znode redisapi-client --restart='Never' \
            --image docker.io/bitnami/redis:7.2.4-debian-11-r2 --command -- sleep infinity

      - name: Create DB Secrets
        run: |
          kubectl create secret generic znode10x-secrets \
            --type=Opaque \
            --namespace ${{ inputs.namespace }} \
            --from-literal=DB_WBST="${{ secrets.DB_WBST }}" \
            --from-literal=DB_PYMT="${{ secrets.DB_PYMT }}" \
            --from-literal=DB_HGFR="${{ secrets.DB_HGFR }}" \
            --from-literal=DB_RCEG="${{ secrets.DB_RCEG }}" \
            --from-literal=STORAGE_CONN="${{ secrets.STORAGE_CONN }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply Required Secrets
        working-directory: ./helm-aks/znode10-helm/ssl/${{ vars.DOMAIN }}
        run: |
          kubectl create secret tls api-tls-secret --cert=${{ vars.DOMAIN }}.crt --key=${{ vars.DOMAIN }}.key -n ${{ github.event.inputs.namespace}}
          kubectl create secret docker-registry prodacrsecret --namespace znode --docker-server=${{ secrets.PROD_ACR_SERVER }} --docker-username=${{ secrets.ACRUNPROD }} --docker-password=${{ secrets.ACRPWPROD }}
          kubectl create secret docker-registry nonprodacrsecret --namespace znode --docker-server=${{ secrets.NP_ACR_SERVER }} --docker-username=${{ secrets.ACRUN_NP }} --docker-password=${{ secrets.ACRPW_NP }}
          kubectl create secret docker-registry tenantacrsecret --namespace znode --docker-server=${{ vars.TENANT_ACR_SERVER }} --docker-username=${{ secrets.TENANT_ACRUN }} --docker-password=${{ secrets.TENANT_ACRPW }}
          kubectl create secret generic znode10storage --from-literal azurestorageaccountname=${{ secrets.STORAGE_NAME }} --from-literal azurestorageaccountkey=${{ secrets.STORAGE_KEY }} --type=Opaque -n ${{ github.event.inputs.namespace}}


      - name: Helm Upgrade or Install DB Chart
        working-directory: ./helm-aks/znode10-helm-db
        run: |
          helm upgrade --install znode10-helm-db . \
            -f ${{ vars.CATEGORY }}-db-values.yml \
            --namespace znode \
            --set global.clusterType=${{ vars.CLUSTER_TYPE }}

      - name: Helm Install ingress chart
        working-directory: ./helm-aks/znode10-helm
        run: |
            helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
            helm repo update
            helm upgrade --install  ${{ github.event.inputs.tenant }}${{ github.event.inputs.environment }} ingress-nginx/ingress-nginx \
            --namespace znode \
            --set controller.service.type=LoadBalancer \
            --set controller.service.loadBalancerIP=${{ github.event.inputs.ingressip }} \
            --set controller.service.externalTrafficPolicy=Local \
            --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-internal"="true" \
            --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-internal-subnet"="snet-aks-${{ github.event.inputs.tenant }}-${{ github.event.inputs.environment }}" \
            --set controller.ingressClass=${{ github.event.inputs.tenant }}${{ github.event.inputs.environment }} \
            --set controller.ingressClassName=${{ github.event.inputs.tenant }}${{ github.event.inputs.environment }} \
            --set controller.ingressClassResource.name=${{ github.event.inputs.tenant }}${{ github.event.inputs.environment }} \
            --set controller.ingressClassResource.enabled=true

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq          

      - name: Helm install znode10 chart
        working-directory: ./helm-aks/znode10-helm
        run: |
          echo "Deploying to environment: ${{ inputs.tenant }}${{ inputs.environment }}"
          echo '${{ vars.IMAGE_TAGS }}' > image_tags.json
          set_args=""
          for service in $(jq -r 'keys[]' image_tags.json); do
            tag=$(jq -r --arg svc "$service" '.[$svc]' image_tags.json)
            if [[ -n "$tag" && "$tag" != "null" ]]; then
              echo "‚úÖ Using provided tag for $service: $tag"
            else
              current_image=$(kubectl get deployment $service -n ${{ inputs.namespace }} -o jsonpath='{.spec.template.spec.containers[0].image}' || true)
              if [[ -n "$current_image" ]]; then
                current_tag=$(echo "$current_image" | awk -F':' '{print $2}')
                tag="$current_tag"
              else
                echo "‚ùå ERROR: Deployment for $service not found. Cannot continue."
                exit 1
              fi
            fi
            set_args="$set_args --set-string resources.$service.image.tag=$tag"
          done

          helm upgrade --install znode10x . \
            --namespace ${{ inputs.namespace }} \
            -f default-values.yml \
            -f values.yml \
            -f ${{ github.event.inputs.tenant }}-${{ github.event.inputs.environment }}-values.yml \
            -f ingress-values.yml \
            -f ${{ vars.CATEGORY }}-values.yml \
            --set global.tenant=${{ inputs.tenant }} \
            --set global.environment=${{ inputs.environment }} \
            --set global.domain=${{ vars.URL }} \
            --set global.webstoreURL=${{ vars.WEBSTORE_URL }} \
            --set global.imageRegistry=${{ vars.ACR_SERVER }} \
            --set global.imagePullSecrets=${{ vars.BLACKBOX }} \
            --set global.tenantacr.imageRegistry=${{ vars.TENANT_ACR_SERVER }} \
            --set global.clusterType=${{ vars.CLUSTER_TYPE }} \
            --set global.ingressClassName=${{ github.event.inputs.tenant }}${{ github.event.inputs.environment }} \
            --set-string global.db.wbst_db='${{ secrets.DB_WBST }}' \
            --set-string global.db.pymt_db='${{ secrets.DB_PYMT }}' \
            --set-string global.db.hgfr_db='${{ secrets.DB_HGFR }}' \
            --set-string global.db.rceg_db='${{ secrets.DB_RCEG }}' \
            --set-string storage.name="${{ secrets.STORAGE_NAME }}" \
            --set-string storage.url="https://${{ secrets.STORAGE_NAME }}.blob.core.windows.net" \
            --set-string storage.connection_string="${{ secrets.STORAGE_CONN }}" \
            --set-string global.newrelic.licensekey="${{ secrets.NEWRELIC_KEY }}" \
            --set-string global.key.domainkey="${{ vars.DOMAIN_KEY }}" \
            $set_args


      - name: Apply ingress and restart
        run: |
          kubectl rollout restart deployment ${{ github.event.inputs.tenant }}${{ github.event.inputs.environment }}-ingress-nginx-controller -n ${{ github.event.inputs.namespace}}
